## Softeer Level_2

### 1. 금고 털이
- 문제 설명 :  루팡은 배낭을 하나 메고 은행금고에 들어왔다. 금고 안에는 값비싼 금, 은, 백금 등의 귀금속 덩어리가 잔뜩 들어있다. 배낭은 W ㎏까지 담을 수 있다. 각 금속의 무게와 무게당 가격이 주어졌을 때 배낭을 채울 수 있는 가장 값비싼 가격은 얼마인가? 루팡은 전동톱을 가지고 있으며 귀금속은 톱으로 자르면 잘려진 부분의 무게만큼 가치를 가진다.


- 해결 방법 : 가장 값비싼 가격을 찾는 최적화 문제이며 최적화 문제는 그리디알고리즘과 다이나믹 프로그래밍이 대표적이다. 해당 문제는 다이나믹 프로그래밍이 아닌 그리디 알고리즘을 이용하여 해결할 수 있다. 그 이유는 문제에서 귀금속은 톱으로 자를 수 있다라는 조건을 주었기 때문에 가장 값비싼 귀금속을 넣는 그리디 알고리즘을 이용해야 한다. 
1. 가장 값비싼 귀금속을 찾기 위해서 구조체를 선언 후 해당 귀금속의 무게당 가치가 가장 높은 귀금속 기준으로 내림차순으로 정렬
2. 가방에 귀금속을 넣을 수 있으면 가장 값비싼 귀금속을 순차적으로 넣어주면 된다.

### 2. 장애물 인식 프로그램
- 문제 설명 :  지도를 입력하여 장애물 블록수를 출력하고, 각 블록에 속하는 장애물의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.


- 해결 방법 : 백준 S1 단지 붙이기 문제랑 같은 유형의 문제이며 N x N 행렬을 DFS 또는 BFS로 탐색하는 문제이다. 
1. point 구조체를 선언하여 x,y 좌표값을 기억
2. DFS 탐색을 하면서 상하좌우로 그래프 탐색 가능성 체크
3. 새로운 좌표가 인덱스 범위 내에 있으면서 map에서 1로 체크되어 있고, 최초 방문이면 방문
4. 새로운 좌표를 기준으로 새롭게 DFS탐색
위 방법으로 그래프를 탐색하여 인접한 장애물 그룹을 묶어준다. 행렬을 만드는 과정에서 n2의 시간복잡도가 이미 실행되었으므로 최대값을 구하는 연산을 2중 for문을 사용해도 상관없다.