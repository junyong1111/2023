## Softeer Level_2

### 1. 금고 털이
- 문제 설명 :  루팡은 배낭을 하나 메고 은행금고에 들어왔다. 금고 안에는 값비싼 금, 은, 백금 등의 귀금속 덩어리가 잔뜩 들어있다. 배낭은 W ㎏까지 담을 수 있다. 각 금속의 무게와 무게당 가격이 주어졌을 때 배낭을 채울 수 있는 가장 값비싼 가격은 얼마인가? 루팡은 전동톱을 가지고 있으며 귀금속은 톱으로 자르면 잘려진 부분의 무게만큼 가치를 가진다.


- 해결 방법 : 가장 값비싼 가격을 찾는 최적화 문제이며 최적화 문제는 그리디알고리즘과 다이나믹 프로그래밍이 대표적이다. 해당 문제는 다이나믹 프로그래밍이 아닌 그리디 알고리즘을 이용하여 해결할 수 있다. 그 이유는 문제에서 귀금속은 톱으로 자를 수 있다라는 조건을 주었기 때문에 가장 값비싼 귀금속을 넣는 그리디 알고리즘을 이용해야 한다. 
1. 가장 값비싼 귀금속을 찾기 위해서 구조체를 선언 후 해당 귀금속의 무게당 가치가 가장 높은 귀금속 기준으로 내림차순으로 정렬
2. 가방에 귀금속을 넣을 수 있으면 가장 값비싼 귀금속을 순차적으로 넣어주면 된다.

### 2. 장애물 인식 프로그램
- 문제 설명 :  지도를 입력하여 장애물 블록수를 출력하고, 각 블록에 속하는 장애물의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.


- 해결 방법 : 백준 S1 단지 붙이기 문제랑 같은 유형의 문제이며 N x N 행렬을 DFS 또는 BFS로 탐색하는 문제이다. 
1. point 구조체를 선언하여 x,y 좌표값을 기억
2. DFS 탐색을 하면서 상하좌우로 그래프 탐색 가능성 체크
3. 새로운 좌표가 인덱스 범위 내에 있으면서 map에서 1로 체크되어 있고, 최초 방문이면 방문
4. 새로운 좌표를 기준으로 새롭게 DFS탐색
위 방법으로 그래프를 탐색하여 인접한 장애물 그룹을 묶어준다. 행렬을 만드는 과정에서 n2의 시간복잡도가 이미 실행되었으므로 최대값을 구하는 연산을 2중 for문을 사용해도 상관없다.

### 3. 지도 자동 구축
- 문제 설명 :  현대자동차그룹이 레벨3 자율주행차 상용화 목표에 발맞춰 총력을 다하고 있는 가운데, 국내 최고 수준의 지도 구축 기술력을 보유한 현대엠엔소프트는 자율주행에 필요한 정밀지도를 제작해 배포하고, 기술 고도화를 위한 연구에 매진하고 있다.
최근에는 도로 데이터를 기반으로 자동으로 정밀지도를 구축하는 ‘지도 자동 구축(Map Auto Creation, 이하 MAC)’ 기술을 개발해 지도 제작 시간을 단축하고 정밀도를 향상시키는 데 성공했다.

자율주행차용 정밀 지도에 관한 궁금증으로 인터넷 검색을 해보니, Diamond-Square-Algorithm이라는 것을 찾게 되었다. 이 알고리즘은 정사각형을 이루는 점 4개를 고르고 그 후에는 다음과 같은 과정을 거쳐 모양이 만들어진다.

1. 정사각형의 각 변의 중앙에 점을 하나 추가한다.
2. 정사각형의 중심에 점을 하나 추가한다.

- 해결 방법 : 이 문제는 반복횟수가 증가함에 따라 규칙을 찾아 재귀적으로 구현하면 되는 문제이며, 규칙만 찾으면 쉽게 해결할 수 있는 문제였다. 하지만 규칙을 찾는데 시간이 좀 걸렸다.
1. N==0 base case -> 반복횟수가 0이라면 4를 반환
2. N>0 
- MAC(n-1)값을 미리 저장
- 위 값을 이용하여 나머지 4개의 사각형의 점을 구해야 한다.
    - 4등분으로 나눈 사각형의 첫번째 부분은 이전값으로 넣음
    - 나머지 3개 중 2개의 사각형의 점의 개수는 MAC(n-1) - sqrt(MAC(n-1)) *2 이다.
        - 2개의 사각형에서 1번째 사각형과 겹치는 부분은 가로 또는 세로의 node의 개수임
        - node의 개수는 정사각형이므로 모든 점의 개수의 제곱근을 구하면 된다.
    - 마지막 1개의 사각형은 이전 2개의 사각형의 개별 크기 - sqrt(MAc(n-1))로 겹치는 부분을 제거
- 마지막 중앙의 점을 추가 후 반환

### 4. GBC
- 문제 설명 :  빌딩에서 운영되는 엘리베이터 구간은 N개의 구간으로 나뉘며 해당 구간의 제한 속도이 주어진다. 구간의 총 합은 100m 이며 각 구간별 구간의 길이와 제한 속도 모두 양의 정수로 주어진다.

예를 들어보자. 구간이 3이라고 할 때,
▶ 첫 번째 구간의 길이는 50m 이고 제한 속도는 50m/s
▶ 두 번째 구간의 길이는 40m 이고 제한 속도는 40m/s
▶ 세 번째 구간의 길이는 10m 이고 제한 속도는 30m/s

이 구간에서 제한 속도를 벗어나면(즉 제한속도를 초과하면) 서버에 초과한만큼의 속도가 로그에 남는다. 불행하게도 현재 서버의 상태가 off 상태임으로 광우는 서버의 데이터를 받아볼 수가 없다. 광우는 임의의 구간의 길이와 속도를 정하여 시범운행 할 때, 가장 제한 속도가 크게 벗어난 값을 스스로 구해야 한다.

M개의 구간을 검사한다고 할 때 예를 들면,
▶ 첫 번째 구간의 운행 길이는 60m 이고 속도는 76m/s
▶ 두 번째 구간의 운행 길이는 18m 이고 속도는 28m/s
▶ 세 번째 구간의 운행 길이는 22m 이고 속도는 50m/s이라고 했을 때, 제한 속도를 벗어나 가장 차이가 큰 속도를 구해 보자.

- 해결 방법 : 해당 문제는 단순한 코드 구현 문제이지만 구현하는데 있어서 여러 실수들이 존재했다. 단순하지만 사소한 실수를 조심해야 풀 수 있는 문제이다.
1. 해당 구간 및 제한속도 정보를 저장하기 위한 speed 구조체 선언
2. 총 길이를 미리 구해서 총 길이만큼 반복 진행
3. 현재 제한 구간 및 속도를 저장 후 테스트 주행거리와 비교
    - 만약 제한 속도를 초과한 경우 최대 초과 속도와 비교 후 갱신
    - 테스트 주행거리가 남았다면 테스트 주행거리 갱신 및 총 거리 갱신 후 제한속도 인덱스 증가
    - 테스트 주행거리가 남지 않았다면 테스트 주행거리가 남은 만큼 제한 거리 추가 후 테스트 인덱스 증가