# Object-Oriented Analysis and Design(OOAD)


### OOAD - 01  Introduction

<details>
<summary> OOAD - 01  Introduction </summary>
<div markdown="1">   

**객체 지향적 분석과 디자인은 무엇인가?**

- 객체지향적 분석 : Concept를 넣어주는 것
- 객체지향적 디자인 : 소프트웨어 객체를 설계하는 것(문제 잡기)

**객체지향은 객체의 표현을 강조한다.**

- 책을 예제로 한다면 책은 보는사람마다 책에 대한 트겅을 다르게 볼 수 있다.
    - 서점에서는 보는 책에 대한 관점과 운송업체에서 보는 책에 대한 관점은 다르다.
- 같은 비행기(고유넘버)가 존재하더라도 비행을 끝내면 승무원 ,운항정보 등을 모두 교체

</div>
</details>

### OOAD - 02  OOAD-Example

<details>
<summary> OOAD - 02  OOAD-Example </summary>
<div markdown="1">   

**Use Cases 정의**

- **메인 기능과 연관된 설명**
- 주사위를 던지는 게임
    - 주사위 2개를 굴려 합이 7이 되면 이기는 게임

**Domain Model 정의**

**시스템의 도메인(영역)을 표현하는 개념적인 모델**

- 객체별 분류 관점에서 도메인에 대한 설명 만들기
- 도메인을 분해하려면 개념, 속성 및 연관성을 식별
- 객체의 도메인 개념들을  보여준다.

**상호작용 다이어그램 정의**

**실제로 어떻게 돌아갈지 계획(설계)**

- 각각의 소프트웨어 객체들이 어떻게 서로 상호작용해야 하는지 설계

**클래스 다이어그램 정의**

**클래스와 클래스 간의 관계를 시각적으로 표현하는 다이어그램**

- 콘셉과는 다르게 될 수 있음
- 소프트웨어적 설계 시 필요한 클래스만 설계

</div>
</details>



### OOAD - 03  Iterative Evolutionary

<details>
<summary>OOAD - 03  Iterative Evolutionary </summary>
<div markdown="1">   

**UP(Unified Process) 개발 방법론**

**UP개발 방법론은 객체지향 시스템을 building하기 위한 대중적인 소프트웨어 개발 방법이다**

—# 또 다른 표현으로는 Rational UP or RUP

**UP-1**

- UP의 아이디어 : **반복적인 개발**
- 이러한 반복적인 접근은 아래와 같은 과정들이 포함되어 있다.
    - 짧은 시리즈
    - 고정된 길이(예를 들어 4주)
    - 미니 프로젝트라고 불리는 반복들
- 설계를 하면서 코드를 만들어 간다.

**UP-2**

- **각각의 반복은 자신만의 요구사항들, 분석, 디자인, 구현 그리고 테스트과정을 포함하고 있다.**
- 반복에의해 시간이 지남에 따라 점진적으로 개발된다.
    - **ierative and incremental development**
    

**Iterative Development**

- Development : 짧은 시리즈와 고정된 길이, 미니프로젝트라고 불리는 과정의 반복
- 각각의 반복은 자신만의 요구사항들, 분석, 디자인, 구현 그리고 테스트과정을 포함하고 있다.

**UP의 Iterative Developmentdm의 장점**

- 초기위험을 미리 발견 가능
- 반복을 통해 점진적으로 개발 가능

❗️ UP는 **고정된 길이의(예를 들면 4주)짧은 개발의 연속이며 미니프로젝트라고 불리는 작업의 반복이다. 이 반복적인 과정을 통해서 시스템은 시간이 지남에 따라 점진적으로 자라며, 이러한 과정은 iterative and incremental developemnet라고 잘 알려져 있다.**

</div>
</details>


### OOAD - 04  UP

<details>
<summary> OOAD - 04  UP </summary>
<div markdown="1">   

**SW 개발 과정(방법론)**

**Waterfall Model**

**폭포수가 떨어지듯 연결된 활동으로 일련의 과정들이 구성되어 있다.**

| 장점 | 단점 |
| --- | --- |
| - 초기에 요구사항을 잘 정의하고 계획 가능
- 프로젝트의 전체 진행 상황을 문서로 추적하기 쉬움 | - 변경에 대한 유연성이 낮음
- 프로젝트 초기에 요구사항을 완벽하게 정의하기 어려움 |
- **한 번 계획되면 그 상태로 끝임**
- **작은 사이즈 프로그램을 계획할 때 사용하기 좋음**
    - feedback이 있는 경우에는 사용하기 힘듬

**Waterfall Model**

**반복적으로 개발하는 방법으로 가장 잘 알려져 있는 모델로는 UP가 존재한다.**

**각각 반복할 때마다 가장 중요한 일 먼저 한다.**

**UP**

| UP 방법론 장점 | UP 방법론 단점 |
| --- | --- |
| 상세한 계획을 통해 개발 방향성 명확 | 초기 계획에 대한 요구사항 변화에 대응 어려움 |
| 엄격한 품질 관리 절차로 품질 보장 | 높은 비용 및 시간 소요 |
| 대규모 프로젝트에 적합 | 엄격한 절차로 인한 개발 프로세스 무거움 |
| 문서화와 검증에 중점, 후속 유지보수 용이 | 고객과의 지속적인 협력과 빠른 변화에 대응 어려움 |

![IMG_52FFB45E2B65-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d12396e-7819-430c-873c-d7a8f358052b/IMG_52FFB45E2B65-1.jpeg)

- **Inception(개시)**
    - **이번 프로젝트를 무엇을 할지, 어느만큼 할지 정하는 단계**
    
    <aside>
    ❗ Inception단계는 개발자가 해당 문제를 정해진 자원(시간, 비용, 인원 등등…)으로 해결할 수 있는지 확인하는 단계이며 프로젝트에 대해서 진행, 협상 또는 중단을 하는 단계이다.
    
    </aside>
    
- **Elaboration(상세화)**
    - **분석 설계에 집중하는 단계**
    - 프로토타입을 통해 시스템의 기능과 성능을 검증하고, **리스크를 식별**하고 **대응 방안을 수립**
    - 끝나면 더이상 중심 구조를 더 이상 수정하지 않음
    
    <aside>
    ❗ 핵심 아키텍처가 반복적으로 구현되며 리스크를 식별하고 대응 방안을 수립하여 High-risk문제들이 완화되는 단계이며 상세화 과정이 끝나면 milestone이 생성되며 중심 구조를 더 이상 수정하지 않는다.
    
    </aside>
    
- **Construction(구축)**
    - Elaboration 단계에서 정의한 상세한 요구사항에 따라 소프트웨어를 실제로 개발하는 단계
    - **반복적으로 구현(코딩)하는 단계**
    
    <aside>
    ❗ 소프트웨어를 개발하여 릴리즈(Release)하는 것이 일반적이다. Construction 단계는 Elaboration 단계에서 정의된 아키텍처에 따라 실제로 소프트웨어를 개발하고 테스트하는 단게
    
    </aside>
    
- **Transition(전환)**
    - **시스템의 최종 품질을 검증하고 프로젝트를 완료하는 단계**
    - Beta tests, deployment.

</div>
</details>



### OOAD - 05  UP Phases

<details>
<summary> OOAD - 05  UP Phases </summary>
<div markdown="1">   

**UP 개발 과정(방법론)**

![IMG_52FFB45E2B65-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d12396e-7819-430c-873c-d7a8f358052b/IMG_52FFB45E2B65-1.jpeg)

- **Inception(개시)**
    - **이번 프로젝트를 무엇을 할지, 어느만큼 할지 정하는 단계**
    
    <aside>
    ❗ Inception단계는 개발자가 해당 문제를 정해진 자원(시간, 비용, 인원 등등…)으로 해결할 수 있는지 확인하는 단계이며 프로젝트에 대해서 진행, 협상 또는 중단을 하는 단계이다.
    
    </aside>
    
- **Elaboration(상세화)**
    - **분석 설계에 집중하는 단계**
    - 프로토타입을 통해 시스템의 기능과 성능을 검증하고, **리스크를 식별**하고 **대응 방안을 수립**
    - 끝나면 더이상 중심 구조를 더 이상 수정하지 않음
    
    <aside>
    ❗ 핵심 아키텍처가 반복적으로 구현되며 리스크를 식별하고 대응 방안을 수립하여 High-risk문제들이 완화되는 단계이며 상세화 과정이 끝나면 milestone이 생성되며 중심 구조를 더 이상 수정하지 않는다.
    
    </aside>
    
- **Construction(구축)**
    - Elaboration 단계에서 정의한 상세한 요구사항에 따라 소프트웨어를 실제로 개발하는 단계
    - **반복적으로 구현(코딩)하는 단계**
    
    <aside>
    ❗ 소프트웨어를 개발하여 릴리즈(Release)하는 것이 일반적이다. Construction 단계는 Elaboration 단계에서 정의된 아키텍처에 따라 실제로 소프트웨어를 개발하고 테스트하는 단게
    
    </aside>
    
- **Transition(전환)**
    - **시스템의 최종 품질을 검증하고 프로젝트를 완료하는 단계**
    - Beta tests, deployment.
    
    1. Business Modeling: 비즈니스 모델링은 프로젝트의 비즈니스 요구사항을 이해하고 문제를 해결하기 위해 사용자 요구사항을 수집하고 분석하는 활동을 포함합니다. 비즈니스 프로세스, 데이터 모델링, 사용자 시나리오 등의 기법을 사용하여 비즈니스 요구사항을 도출하고 문서화합니다.
    2. Requirements: 요구사항 관리는 사용자와의 커뮤니케이션을 통해 요구사항을 수집, 분석, 문서화하고 관리하는 활동을 포함합니다. 요구사항의 우선순위 결정, 변경 관리, 검증 및 승인 등의 과정을 통해 요구사항을 관리하고 변경에 대응합니다.
        - FR(Functional Requirments) : 출금 (가장 중요한 요구사항)
            - Use cases와 세트임
        - NFR(None Functional Requirments) : 속도 (돈은 나오더라도 느리게 나오는 경우)
            - 빠르게, 아름답게, 견고하게.. Quality와 세트
    3. Analysis & Design: 분석 및 설계는 시스템 아키텍처와 디자인을 수행하는 활동을 포함합니다. 시스템의 기능, 구조, 동작을 분석하여 상세한 디자인을 수행하고, 시스템의 모델링, 패턴, 아키텍처 등을 설계합니다.
    4. Implementation: 구현은 설계된 시스템을 실제 코드로 구현하는 활동을 포함합니다. 개발자들은 프로그래밍 언어, 개발 환경, 개발 도구 등을 사용하여 소프트웨어를 개발하고, 코드를 작성하고, 테스트를 수행합니다.
    5. Test: 테스트는 개발된 소프트웨어의 품질과 안정성을 검증하는 활동을 포함합니다. 다양한 테스트 기법과 도구를 사용하여 소프트웨어의 기능, 성능, 보안 등을 테스트하고 검증합니다.
    6. Deployment: 배포는 개발된 소프트웨어를 사용자에게 제공하는 과정을 포함합니다. 소프트웨어의 설치, 설정

![스크린샷 2023-04-24 오후 7.33.49.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1222411c-9814-43de-996c-92e1643ed3bd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-04-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.33.49.png)

</div>
</details>




<!-- 
<details>
<summary>  </summary>
<div markdown="1">   

</div>
</details> -->